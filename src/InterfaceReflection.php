<?php


namespace TS\Protobuf;


use Generator;
use Google\Protobuf\Internal\Message;
use LogicException;
use phpDocumentor\Reflection\DocBlock\Tags\Return_;
use phpDocumentor\Reflection\DocBlockFactory;
use phpDocumentor\Reflection\Types\ContextFactory;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
use ReflectionParameter;
use Symfony\Component\PropertyInfo\Util\PhpDocTypeHelper;
use UnexpectedValueException;


class InterfaceReflection
{


    /**
     * @param string $service The protobuf service interface generated by protoc with option php_generic_services = true
     * @return InterfaceReflection
     */
    public static function create(string $service): self
    {
        try {
            $refClass = new ReflectionClass($service);
            if (!$refClass->isInterface()) {
                $msg = sprintf('Service %s is not an interface. You must pass the protobuf service interface generated by protoc.', $service);
                throw new UnexpectedValueException($msg);
            }

            return new self($refClass);

        } catch (ReflectionException $e) {
            throw new UnexpectedValueException($e, $e->getCode(), $e);
        }

    }


    /** @var ReflectionClass */
    private $reflection;

    /**
     * Holds already built methods by name.
     * @var InterfaceMethodReflection[]
     */
    private $methodCache;

    private $protobufTypeCache;

    private $contextFactory;
    private $docBlockFactory;
    private $typeHelper;


    public function __construct(ReflectionClass $serviceInterface)
    {
        $this->reflection = $serviceInterface;
        $this->contextFactory = new ContextFactory();
        $this->docBlockFactory = DocBlockFactory::createInstance();
        $this->typeHelper = new PhpDocTypeHelper();
        $this->methodCache = [];
    }


    /**
     * The fully qualified name of the service interface.
     *
     * @return string
     */
    public function getName(): string
    {
        return $this->reflection->getName();
    }


    /**
     * The protobuf type of the service.
     *
     * @return string
     */
    public function getProtobufType(): string
    {
        if (is_null($this->protobufTypeCache)) {
            $docComment = $this->reflection->getDocComment();
            if (!is_string($docComment) || strlen(trim($docComment)) === 0) {
                $msg = sprintf('Unexpected service interface %s: doc block not found.', $this->getName());
                throw new UnexpectedValueException($msg);
            }
            $ok = preg_match('/Protobuf type <code>([a-zA-Z0-9.-_]+)<\/code>/', $docComment, $matches);
            if ($ok === false) {
                throw new LogicException();
            }
            if (count($matches) !== 2 || strlen(trim($matches[1])) === 0) {
                $msg = sprintf('Unexpected service interface %s: <code> element with protobuf type not found in doc block.', $this->getName());
                throw new UnexpectedValueException($msg);
            }
            $this->protobufTypeCache = trim($matches[1]);
        }
        return $this->protobufTypeCache;
    }


    /**
     * @return InterfaceMethodReflection[]
     */
    public function getMethods(): array
    {
        $a = [];
        foreach ($this->filterReflectionMethods() as $refMethod) {
            $a[] = $this->buildMethod($refMethod);
        }
        return $a;
    }


    public function findMethod(string $name, bool $caseSensitive = false): ?InterfaceMethodReflection
    {
        $needle = $caseSensitive ? $name : strtolower($name);
        foreach ($this->filterReflectionMethods() as $refMethod) {
            $hay = $caseSensitive ? $refMethod->getName() : strtolower($refMethod->getName());
            if ($hay !== $needle) {
                continue;
            }
            return $this->buildMethod($refMethod);
        }
        return null;
    }


    public function validateImplementation($implementation): void
    {
        if (!is_object($implementation)) {
            $msg = sprintf('Expected service implementation to be an object implementing %s. Got a %s instead.', $this->getName(), gettype($implementation));
            throw new UnexpectedValueException($msg);
        }

        if (!is_a($implementation, $this->getName(), true)) {
            $msg = sprintf('Expected service implementation to be an object implementing %s. Got a %s instead.', $this->getName(), get_class($implementation));
            throw new UnexpectedValueException($msg);
        }
    }


    /**
     * @return ReflectionMethod[]|Generator
     */
    private function filterReflectionMethods(): Generator
    {
        $refMethods = $this->reflection->getMethods(ReflectionMethod::IS_PUBLIC);
        foreach ($refMethods as $refMethod) {
            if (!$refMethod->isConstructor()) {
                yield $refMethod;
            }
        }
    }


    private function buildMethod(ReflectionMethod $refMethod): InterfaceMethodReflection
    {
        if (!array_key_exists($refMethod->getName(), $this->methodCache)) {
            $refParameter = $this->readParameter($refMethod);
            $parameterName = $refParameter->getName();
            $parameterType = $refParameter->getType()->getName();
            if (!is_a($parameterType, Message::class, true)) {
                $msg = sprintf('Unexpected service method %s::%s: parameter type %s is not a %s.', $this->getName(), $refMethod->getName(), $parameterType, Message::class);
                throw new UnexpectedValueException($msg);
            }
            $returnType = $this->readReturnType($refMethod);
            if (!is_a($returnType, Message::class, true)) {
                $msg = sprintf('Unexpected service method %s::%s: return type is not a %s.', $this->getName(), $refMethod->getName(), Message::class);
                throw new UnexpectedValueException($msg);
            }
            $this->methodCache[$refMethod->getName()] = new InterfaceMethodReflection($refMethod, $parameterName, $parameterType, $returnType);
        }
        return $this->methodCache[$refMethod->getName()];
    }


    private function readParameter(ReflectionMethod $refMethod): ReflectionParameter
    {
        if ($refMethod->getNumberOfParameters() !== 1) {
            $msg = sprintf('Unexpected service method %s::%s: services can only have exactly one argument, found %s.', $this->getName(), $refMethod->getName(), $refMethod->getNumberOfParameters());
            throw new UnexpectedValueException($msg);
        }
        $refParameter = $refMethod->getParameters()[0];
        if (!$refParameter->hasType()) {
            $msg = sprintf('Unexpected service method %s::%s: parameter "%s" has no type information.', $this->getName(), $refMethod->getName(), $refParameter->getName());
            throw new UnexpectedValueException($msg);
        }
        if ($refParameter->getType()->isBuiltin()) {
            $msg = sprintf('Unexpected service method %s::%s: parameter "%s" has built in type.', $this->getName(), $refMethod->getName(), $refParameter->getName());
            throw new UnexpectedValueException($msg);
        }
        return $refParameter;
    }


    private function readReturnType(ReflectionMethod $refMethod): string
    {
        $docComment = $refMethod->getDocComment();
        if (!is_string($docComment) || strlen(trim($docComment)) === 0) {
            $msg = sprintf('Unexpected service method %s::%s: doc block not found.', $this->getName(), $refMethod->getName());
            throw new UnexpectedValueException($msg);
        }

        $docBlock = $this->docBlockFactory->create($docComment, $this->contextFactory->createFromReflector($refMethod));

        /** @var Return_[] $returnTags */
        $returnTags = $docBlock->getTagsByName('return');
        if (count($returnTags) !== 1) {
            $msg = sprintf('Unexpected service method %s::%s: no return type information found in doc block.', $this->getName(), $refMethod->getName());
            throw new UnexpectedValueException($msg);
        }

        $returnTagType = $returnTags[0]->getType();
        $typeInfos = $this->typeHelper->getTypes($returnTagType);
        if (count($typeInfos) !== 1) {
            $msg = sprintf('Unexpected service method %s::%s: unable to read return type information from doc block.', $this->getName(), $refMethod->getName());
            throw new UnexpectedValueException($msg);
        }

        $returnType = $typeInfos[0]->getClassName();
        if (!is_string($returnType)) {
            $msg = sprintf('Unexpected service method %s::%s: unexpected return type information from doc block.', $this->getName(), $refMethod->getName());
            throw new UnexpectedValueException($msg);
        }

        return $returnType;
    }


}
